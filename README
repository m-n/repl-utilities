REPL-Utilities is a set of utilities which ease life at the repl. It is
tested on SBCL and CCL, and further porting should be trivial. 

For best effect load this package and use-package it from your lisp's init file.

My favorite operator in here is deflex, taken from Rob Warnock and aliased
to lex. It defines a global lexical variable -- this lets you use temporary test variables without earmuffs safely:

(defvar *x* (list 1 2 3)) 
(mapcar #'print *x*) ; painful

(lex x (list 1 2 3)) 
(mapcar #'print x) ; better

If you wish to in-package another package at the repl in the course of
developing it, you can retain access to these repl-utilities by using DEV
instead of asdf:load-system and in-package to load and swap to the new
package. DEV will import the repl-utilities symbols into the new package, if
they won't cause name conflicts.

Following the lead of cl:in-package, the package introspection and management
operators have been defined as macros so that they can take unquoted symbols
as arguments. For convenience they will automatically unquote quoted symbol
arguments.

My next favorite operator provided here is README, which prints the docstrings
for the exported symbols of a package.

 The rest of this files is generated by a call to readme:

(readme repl-utilities)

(EXS &optional (package *package*)) > function
 Print the external symbols of package.

(PRINT-HASH hash-table) > function
 Print the hash table as: Key, Value~% 

(LEX &rest args) > function
 Shortening of deflex: define a global lexical variable.

(EXFNS &optional (package *package*)) > function
 Print the external fboundp symbols of a package.

(EXCS &optional (package *package*)) > function
 Print the external symbols for which find-class is truthy.

(DE &rest rest) > function
 Shortening of describe. A Rob Warnock function.

(DEV package) > function
 Load the package, then swap to it. Import repl-utilities exported symbols that don't conflict.
For use at the repl. Mnemonic for develop.

(BRING package) > function
 Load the package. Import the package's exported symbols that don't conflict.
For use at the repl.

*advised-functions* > variable
 Hash table of [Key <> Value] of 
[symbol-of-advised-function <> symbol-function-before-advice]

(DEFLEX var val &optional (doc nil docp)) > function
 Define a top level (global) lexical VAR with initial value VAL,
  which is assigned unconditionally as with DEFPARAMETER. If a DOC
  string is provided, it is attached to both the name |VAR| and the
  name *STORAGE-FOR-DEFLEX-VAR-|VAR|* as a documentation string of
  kind 'VARIABLE. The new VAR will have lexical scope and thus may be
  shadowed by LET bindings without affecting its dynamic (global) value.

(REMOVE-ADVICE &rest functions) > function
 Clear all advice from given functions, or from all functions if none named.

(DOC func) > function
 Print any documentation for the symbol.
Includes variable, function, structure, type, compiler macro, method
 combination, and setf documentation.

(DEPENDENCY-LOCATIONS system-name) > function
 Takes a string as system-name. Only "works" and only on QL systmes.

(EXTS &optional (package *package*)) > function
 Print the external symbols which are type specifiers.

(ADD-ADVICE symbol advice &optional afterp) > function
 Add an 'advice' function to be called on the arguments before or after
the symbol-function is called on them.

(TRACE-PACKAGE &optional (package *package*) (inheritedp nil)) > function
 Trace all of the symbols in *package*. 

Don't trace :cl or use inheritedp on a package which uses it.

(NIC package-name nick-symbol) > function
 Add an additional nickname to package.

(DBGV (&optional (where debug)
       (stream '*standard-output*)) &body forms) > function
 Print WHERE, execute FORMS, and print each form and its result to the STREAM.

(README &optional (package *package*)) > function
 Print the documentation on the exported functions of a package.

