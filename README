REPL-Utilities is a set of utilities which ease life at the repl. It is
tested on SBCL, CCL and CLISP, and further porting should be trivial. 

For best effect load this package and use-package it from your lisp's init file.

My favorite operator in here is deflex, taken from Rob Warnock and aliased
to lex. It defines a global lexical variable -- this lets you use temporary test variables without earmuffs safely:

(defvar *x* (list 1 2 3)) 
(mapcar #'print *x*) ; painful

(lex x (list 1 2 3)) 
(mapcar #'print x) ; better

If you wish to in-package another package at the repl in the course of
developing it, you can retain access to these repl-utilities by using DEV
instead of asdf:load-system and in-package to load and swap to the new
package. DEV will import the repl-utilities symbols into the new package, if
they won't cause name conflicts.

Following the lead of cl:in-package, the package changing, loading,
and renaming operators (BRING, DEV, and NIC) expand into an eval-when so
that they can take effect before later forms are read.

The symbol and package introspection operators have been defined as macros
to allow their arguments to be unquoted symbols. For convenience they
automatically unquote quoted arguments.

My next favorite operator provided here is README, which prints the docstrings
for the exported symbols of a package.

 The rest of this files is generated by a call to readme:

(readme repl-utilities)

REPL-UTILITIES > ASDF System
 Ease common tasks at the REPL.

(EXS &optional (package *package*)) > macro
 Print the external symbols of package.

*dev-hooks* > variable
 List of functions to be funcalled after a package is loaded with DEV.

 During execution of these functions *PACKAGE* is already set to the package
 being loaded, and the repl-utilities symbols which will be imported already
 are. The functions are called with no arguments.

(LEX &rest args) > macro
 Shortening of deflex: define a global lexical variable.

(EXFNS &optional (package *package*)) > macro
 Print the external fboundp symbols of a package.

(EXCS &optional (package *package*)) > macro
 Print the external symbols for which find-class is truthy.

(DE &rest rest) > function
 Shortening of describe. A Rob Warnock function.

(DEV package) > macro
 Attempt to ql:quickload or asfd:load-system a system with the same name as
   package, then swap to the package regardless of whether the load was
   successful. Import repl-utilities exported symbols that don't cause symbol
   conflicts into the newly swapped to pacage.
Mnemonic for develop.

  After swapping to the package map funcall over *dev-hooks*.

(SUMMARY &optional (package *package*)) > macro
 Print the exported symbols along with the first line of their docstrings.

(BRING package &optional (shadowing-import nil)) > macro
 Attempt to ql:quickload or asdf:load-system a system with the same name as 
  package. Regardless of whether the load was successful import the package's
  exported symbols into the current package. If shadowing-import is nil, only
  the symbols which won't cause a symbol conflict are imported.

  After importing the package funcall each element of *bring-hooks* with the
  package as its argument.

  Expands to an EVAL-WHEN :compile-toplevel :load-toplevel :execute

(PRINT-HASH hash-table) > function
 Print the hash table as: Key, Value~% 

(MAC expr) > macro
 Bind *gensym-counter* to 0, Macroexpand-1 the form, pprint result.

  If expression starts with a quotation, unquotes it first.

(DOC symbol &rest ignored-arguments) > macro
 Print any documentation for the symbol.
Includes variable, function, type, compiler macro, method
 combination, and setf documentation.

(DEPENDENCY-LOCATIONS system-name &optional print-system-names-p operation) > function
 Print the pathname of the system and of the systems needed to operation it.

  Operation should be a symbol naming an operation recognized by
  asfd:component-depends-on, e.g. 'asdf:load-op or 'asfd:test-op.

(EXTS &optional (package *package*)) > macro
 Print the external symbols which are type specifiers.

(SHADOWED-IMPORT symbols &optional package print-when-shadowed-p) > function
 Import each symbol into PACKAGE, unless a symbol of the same name is present.
  If print-when-shadowed-p is true, print a message for each not-imported 
  symbol indicating that it was not imported.

(DEFLEX var val &optional (doc nil docp)) > macro
 Define a top level (global) lexical VAR with initial value VAL,
  which is assigned unconditionally as with DEFPARAMETER. If a DOC
  string is provided, it is attached to both the name |VAR| and the
  name *STORAGE-FOR-DEFLEX-VAR-|VAR|* as a documentation string of
  kind 'VARIABLE. The new VAR will have lexical scope and thus may be
  shadowed by LET bindings without affecting its dynamic (global) value.

*bring-hooks* > variable
 List of functions to be funcalled after a package is loaded with BRING.

 The functions are called with the package imported by bring as their only 
 argument.

(TRACE-PACKAGE &optional (package *package*) (inheritedp nil)) > macro
 Trace all of the symbols in *package*. 

 This won't attempt to trace any symbols in :cl

(NIC package-name nick-symbol) > macro
 Add an additional nickname to package.
  Expands to an EVAL-WHEN :compile-toplevel :load-toplevel :execute

(DBGV (&optional (where debug)
       (stream '*standard-output*)) &body forms) > macro
 Print WHERE, execute FORMS, and print each form and its result to the STREAM.

(README &optional (package *package*)) > macro
 Print the documentation on the exported symbols of a package.

  Expands to an EVAL-WHEN :compile-toplevel :load-toplevel :execute

